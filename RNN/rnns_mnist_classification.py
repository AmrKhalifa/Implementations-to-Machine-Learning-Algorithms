# -*- coding: utf-8 -*-
"""rnns_MNIST_classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZOZX1YRz5KgPb_OcIWBCPZ2reBmAc33v
"""

from data_processor import train_set, test_set
import torch 
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
from torch.optim import Adam
# torch.manual_seed(69)

batch_size = 128
train_loader = torch.utils.data.DataLoader(train_set, batch_size=batch_size)
test_loader = torch.utils.data.DataLoader(test_set, batch_size= batch_size) 
use_cuda = True
device = torch.device("cuda" if (use_cuda and torch.cuda.is_available()) else "cpu")

class RNNClassifier(nn.Module): 
    def __init__(self):
        super(RNNClassifier, self).__init__()
        
        self.enlarger = nn.Linear(in_features =28, out_features = 100)
        self.recurrent = nn.RNN(input_size = 100, hidden_size = 80)
        self.reduced = nn.Linear(in_features = 80, out_features = 10)
    
    def forward(self, x):
        enlarged = F.relu(self.enlarger(x))
        out, hidden = self.recurrent(enlarged)
        output = F.relu(self.reduced(hidden))
        
        return torch.transpose(output, 0,1 ).squeeze()

classifier = RNNClassifier()

def train_rnn_classifier(model, train_loader, n_epochs = 100):
    model.to(device)
    criterion = nn.CrossEntropyLoss()
    learning_rate = .01
    optimizer = Adam(model.parameters(), lr = learning_rate)

    for epoch in range(n_epochs):
      if epoch % 20 == 0:
        learning_rate /= 2 
        optimizer = Adam(model.parameters(), lr = learning_rate)
        for batch in train_loader:
            images, labels = batch
            images, labels = images.to(device), labels.to(device)
            rnn_images = torch.transpose(images.squeeze(), 0,1)

            logits = model(rnn_images)
            loss = criterion(logits, labels)

            print("the loss for this batch is: ", loss.item())

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
    return model

trained_model = train_rnn_classifier(classifier, train_loader)

def test(model, test_data):
  model.eval()
  model.to(device)

  with torch.no_grad():

    correct = 0.0

    for batch in test_data:
      images, labels = batch
      images, labels = images.to(device), labels.to(device)
      preds = model(torch.transpose(images.squeeze(), 0,1))

      correct+= preds.argmax(dim =1).eq(labels).sum().item()

  accuracy = correct / (len(test_set))
  
  print("Accuracy is: ", accuracy)

test(trained_model, test_loader)

|